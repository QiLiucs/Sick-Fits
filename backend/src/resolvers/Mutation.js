const bcrypt=require('bcryptjs');
const jwt=require('jsonwebtoken');
const {randomBytes}=require('crypto');
const {promisify}=require('util');
const {transport,makeANiceEmail}=require('../mail');
const {hasPermission}=require("../utils");
const stripe=require("../stripe");

const mutations = {
    // createDog(parent,args,ctx,info){
    //     global.dogs=global.dogs||[];
    //     //create a dog
    //     const newDog={name:args.name};
    //     global.dogs.push(newDog);
    //     return newDog;
    //     console.log(args)
    // }
    async createItem(parent,args,ctx,info){
        const item=await ctx.db.mutation.createItem({
            data:{
                //create a replationship between the item and its user
                //in this way, this item has an attribute--user, which is actually user id
                user:{
                  connect:{
                      id:ctx.request.userId,
                  }
                },
                ...args
            }
        },info);//info:get to know what to return
        return item;
    },
    async updateItem(parent,args,ctx,info){
        //take a copy of the updates
        const updates={...args};
        console.log(updates);
        // { id: 'cjq1aia7i5htd0991rogpjy5f', price: 100 }
        delete updates.id;
        console.log(updates);
        // { price: 100 }
        const item=await ctx.db.mutation.updateItem({
            data:updates,
            where:{
                id:args.id//thats why we should make a copy
            }
        },info);//info:get to know what to return
        return item;
    },
    async deleteItem(parent,args,ctx,info){

        //find the item
        const where={id:args.id};
        // const item=ctx.db.query.item({where},info);
        //info不行，会出现id is not defined错误
        //如果打印item,出现promise<pending>,意味着还没有执行完成，需要await
        //user must have a subscription
        const item=await ctx.db.query.item({where},`{id title user{id}}`);
        //check if we own the item and our permission,TODO
        const ownsItem=item.user.id===ctx.request.userId;
        const hasPermission=ctx.request.user.permissions.some(
            permission=>["ADMIN","ITEMDELETE"].includes(permission)
        );
        if(ownsItem||hasPermission){
            //do nothing
        }else{
            throw new Error("you dont have the permission!");
        }
        //delete
        return ctx.db.mutation.deleteItem({where},info);
    },
    async signup(parent,args,ctx,info){
        args.email=args.email.toLowerCase();
        //hash their password,10 is salt
        const password=await bcrypt.hash(args.password,10);
        //create user in the db
        //  createUser(data: UserCreateInput!): User!
        const user=await ctx.db.mutation.createUser({
            data:{
                ...args,
                password,//would replace password generated by ...args
                permissions:{set:['USER']},
            }
        },info);
        //create the jwt token for them
        const token=jwt.sign({userId:user.id},process.env.APP_SECRET);
        //set the jwt as a cookie on the response
        ctx.response.cookie('token',token,{
            //cant access it via js
            httpOnly:true,
            maxAge:1000*60*60*24*365,//1 year cookie
        });
        //finalllllly we return the user to the browser
        return user;
    },
    async signin(parent,args,ctx,info){
        //1.check if their is a user with that email
        const email=args.email;
        const user=await ctx.db.query.user({where:{email}});
        if(!user){
            throw new Error(`No such user found for email ${args.email}`);
        }
        //2.if user exists, check if the password is correct
        const valid=await bcrypt.compare(args.password,user.password);
        if(!valid){
            throw new Error("Invalid Password");
        }
        //3.generate the jwt token
        const token=jwt.sign({userId:user.id},process.env.APP_SECRET);
        ctx.response.cookie('token',token,{
            //cant access it via js
            httpOnly:true,
            maxAge:1000*60*60*24*365,//1 year cookie
        });
        //4. return the user
        return user;
    },
    async signout(parent,args,ctx,info){
        ctx.response.clearCookie('token');
        return {message:'GoodBye!'}
    },
    async resetRequest(parent,args,ctx,info){
        //1.check if this is a real user
        const user=ctx.db.query.user({where:{email:args.email}});
        if(!user){
            throw new Error(`No such user found with email ${args.email}`);
        }
        //2.set a reset token and expiry on that user
        //make randomBytes async, so we would use callback func
        const randomBytesPromisified=promisify(randomBytes);
        const resetToken=(await randomBytesPromisified(20)).toString('hex');
        const resetTokenExpiry=Date.now()+3600000;
        const res=await ctx.db.mutation.updateUser({
            where:{email:args.email},
            data:{
                resetToken:resetToken,
                resetTokenExpiry:resetTokenExpiry
            }
        });
        console.log(res);

        //3.email them
        const mailRes=await transport.sendMail({
            from:'liuqi@usc.edu',
            to:args.email,
            subject:"Your Password Reset Token",
            html:makeANiceEmail(`Your Password Reset Token is Here!\n\n
            <a href="${process.env.FRONTEND_URL}/reset?resetToken=${resetToken}">Click Here to Reset</a>
            `)
        });
        return {message:"Thanks!"}
    },
    async resetPassword(parent,args,ctx,info){
        //1.check if the passwords match
        if(args.password!==args.confirmpassword){
            throw new Error("Passwords don't match!");
        }
        //2.check is its a legit reset token
        //3.check if its expired
        //destructure the first returned item to variable user
        const [user]=await ctx.db.query.users({
          where:{
              resetToken:args.resetToken,
              resetTokenExpiry_gte:Date.now()
          }
        });
        if(!user){
            throw new Error("This token is either invalid or expired!");
        }
        //4.hash new password
        const password=await bcrypt.hash(args.password,10);
        //5.save the new password to the user and remove old reset token
        const updateUser=await ctx.db.mutation.updateUser({
            where:{email:user.email},
            data:{
                password,
                resetToken:null,
                resetTokenExpiry:null
            }
        });
        //6.generate jwt
        const token=jwt.sign({userId:updateUser.id},process.env.APP_SECRET);

        //7.set the jwt cookie
        ctx.response.cookie('token',token,{
            //cant access it via js
            httpOnly:true,
            maxAge:1000*60*60*24*365,//1 year cookie
        });
        //8.return the new user
        return updateUser;
    },
    async updatePermission(parent,args,ctx,info){
        //1. check if is logged in
        if(!ctx.request.userId){
            throw new Error("You must be logged in!");
        }
        //2.query the current user
        const currentUser=await ctx.db.query.user(
            {
                where:{
                    id:ctx.request.userId,
                }
            },info
        );
        //3.has the permission?
        hasPermission(currentUser,["ADMIN","PERMISSIONUPDATE"]);
        //4.update
        const newUser=await ctx.db.mutation.updateUser({
            data:{
                permissions:{
                    set:args.permissions,
                }
            },
            where:{
                id:args.userId
            }

        },info);
        return newUser;
    },
    async addToCart(parent,args,ctx,info){
        //1. check if is logged in
        const {userId}=ctx.request;
        //2.query the user's current cart
        const [existingCartItems]=await ctx.db.query.cartItems({
            where:{
                user:{id:userId},
                item:{id:args.id},
            }

        });
        //3.check whether the item is already in the cart, if is, increment the quantity
        //by 1
        if(existingCartItems){
            return ctx.db.mutation.updateCartItem({
                where:{id:existingCartItems.id},
                data:{quantity:existingCartItems.quantity+1}
            },info);
        }
        //4.else create a new cart item
        return ctx.db.mutation.createCartItem({
            data:{
                item: {
                    connect: {id: args.id}
                },
                user:{
                    connect:{id:userId}
                }
            }

        },info);
    },
    async removeFromCart(parent,args,ctx,info){
        //1.find the cart item with the item id
        const cartItem=await ctx.db.query.cartItem({
            where:{
                id:args.id,
            }
        },`{id,user{id}}`);
        //1.5 make sure we found the item
        if(!cartItem){
            throw new Error("No Cartitem Found!");
        }
        //2.make sure own the item
        if(cartItem.user.id!==ctx.request.userId){
            throw new Error("Yo don't have the item");
        }
        //3.delete
        return ctx.db.mutation.deleteCartItem({
            where:{id:args.id},
        },info);

    },
    async createOrder(parent,args,ctx,info){
        //1. query the current user, make sure they are logged in
        const {userId}=ctx.request;
        if(!userId){
            throw new Error("You must be signed in to place this order!");
        }
        //2.recalculate the total price:不让用户告诉你收多少，而是重新计算，防止黑客篡改
        const user=await ctx.db.query.user({
            where:{id:userId}
        },`{
        id
        name
        email
        cart{
            id
            quantity
            item{title price id description image largeImage}
        }}`);
        const amount=user.cart.reduce((tally,cartItem)=>tally+cartItem.item.price*cartItem.quantity,0);
        console.log("amount*******");
        console.log(amount);
        //3.create stripe charge(charge money)
        const charge=await stripe.charges.create({
            amount,
            currency:"USD",
            source:args.token,
        });
        //4.convert the CartItem to OrderItem
        const orderItems=user.cart.map(cartItem=>{
            const orderItem={
                ...cartItem.item,
                quantity:cartItem.quantity,
                user:{connect:{id:userId}}
            };
            delete orderItem.id;
            return orderItem;
        });
        //5.create the order
        const order=ctx.db.mutation.createOrder({
            data:{
                total:charge.amount,
                charge:charge.id,
                items:{create:orderItems},
                user:{connect:{id:userId}}
            }
        });
        //6.clean cart, delete all cartItems of this user
        const cartItemIds=user.cart.map(cartItem=>cartItem.id);
        await ctx.db.mutation.deleteManyCartItems({
            where:{
                id_in:cartItemIds,
            }
        });
        //7.return the order
        return order;

    }
};

module.exports = mutations;
